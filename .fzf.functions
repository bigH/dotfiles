## FZF Helpers

# fzfe - echo's to stderr all files selected
fzfe() {
  fzf "$@" | tee /dev/stderr
}

## CD

# fzd - including hidden directories
fzd() {
  local dir
  dir=$(find ${1:-.} -type d 2> /dev/null | fzf +m --preview="ls -l {}") &&
    echo cd "$dir" &&
    cd "$dir"
}

# fvg - open files that have occurrences of search term
fzvg() {
  if [ -z "$1" ]; then
    echo "ERROR: no argument provided."
  else
    ARGV=$1
    vim $(rg -il $ARGV | fzf -0 -1 -m --ansi --preview "cat {} | rg $ARGV --context 3") "+tabdo /$ARGV"
  fi
}

# CTRL-O - Paste the selected file path(s) into the command line
__fsel_viminfo() {
  local cmd="$FZF_CTRL_O_COMMAND"
  setopt localoptions pipefail 2> /dev/null
  eval "$cmd" | FZF_DEFAULT_OPTS="--height ${FZF_TMUX_HEIGHT:-40%} --reverse $FZF_DEFAULT_OPTS $FZF_CTRL_T_OPTS" $(__fzfcmd) -m "$@" | while read item; do
    # all this is because `(q)` causes `~` to be turned into `\~`, but we also want to make sure to support escaped paths, like `foo bar` turn into `foo\ bar`
    echo -n $(echo -n "${(q)item}" | sed -e 's/\\~/~/g')' '
  done
  local ret=$?
  echo
  return $ret
}

# Will return non-zero status if the current directory is not managed by git
is_in_git_repo() {
  git rev-parse HEAD > /dev/null 2>&1
}

# Select commit from git history
gh() {
  REF="${1:-$HEAD}"
  is_in_git_repo || return
  git log --date=short --format="%C(green)%C(bold)%cd %C(auto)%h%d %s (%an)" --graph --color=always $REF |
  fzf --height 90% --ansi --no-sort --reverse --multi --bind 'ctrl-s:toggle-sort' \
    --header 'Press CTRL-S to toggle sort' \
    --preview 'grep -o "[a-f0-9]\{7,\}" <<< {} | xargs git show -p | diff-so-fancy' |
  grep -o "[a-f0-9]\{7,\}"
}

